// Generated by https://quicktype.io

namespace ECommerceParser.Helpers
{
    using System;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class MyMemory
    {
        [JsonProperty("responseData")]
        public ResponseData ResponseData { get; set; }

        [JsonProperty("quotaFinished")]
        public bool QuotaFinished { get; set; }

        [JsonProperty("mtLangSupported")]
        public object MtLangSupported { get; set; }

        [JsonProperty("responseDetails")]
        public string ResponseDetails { get; set; }

        [JsonProperty("responseStatus")]
        public long ResponseStatus { get; set; }

        [JsonProperty("responderId")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long ResponderId { get; set; }

        [JsonProperty("exception_code")]
        public object ExceptionCode { get; set; }

        [JsonProperty("matches")]
        public Match[] Matches { get; set; }
    }

    public partial class Match
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(DecodingChoiceConverter))]
        public long Id { get; set; }

        [JsonProperty("segment")]
        public string Segment { get; set; }

        [JsonProperty("translation")]
        public string Translation { get; set; }

        [JsonProperty("source")]
        public string Source { get; set; }

        [JsonProperty("target")]
        public string Target { get; set; }

        [JsonProperty("quality", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(DecodingChoiceConverter))]
        public long Quality { get; set; }

        [JsonProperty("reference")]
        public string Reference { get; set; }

        [JsonProperty("usage-count")]
        public long UsageCount { get; set; }

        [JsonProperty("subject")]
        public Subject Subject { get; set; }

        [JsonProperty("created-by")]
        public string CreatedBy { get; set; }

        [JsonProperty("last-updated-by")]
        public string LastUpdatedBy { get; set; }

        [JsonProperty("create-date")]
        public DateTimeOffset CreateDate { get; set; }

        [JsonProperty("last-update-date")]
        public DateTimeOffset LastUpdateDate { get; set; }

        [JsonProperty("match")]
        public double MatchMatch { get; set; }

        [JsonProperty("model", NullValueHandling = NullValueHandling.Ignore)]
        public string Model { get; set; }
    }

    public partial class ResponseData
    {
        [JsonProperty("translatedText")]
        public string TranslatedText { get; set; }

        [JsonProperty("match")]
        public double Match { get; set; }
    }

    public partial struct Subject
    {
        public bool? Bool;
        public string String;

        public static implicit operator Subject(bool Bool) => new Subject { Bool = Bool };
        public static implicit operator Subject(string String) => new Subject { String = String };
    }

    public partial class MyMemory
    {
        public static MyMemory FromJson(string json) => JsonConvert.DeserializeObject<MyMemory>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this MyMemory self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                SubjectConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DecodingChoiceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return integerValue;
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return l;
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value);
            return;
        }

        public static readonly DecodingChoiceConverter Singleton = new DecodingChoiceConverter();
    }

    internal class SubjectConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Subject) || t == typeof(Subject?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Subject { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Subject { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Subject");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Subject)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Subject");
        }

        public static readonly SubjectConverter Singleton = new SubjectConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}
